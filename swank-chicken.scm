;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SWANK server
;;;
;;; This section provides the plumbing to allow SLIME to tunnel requests into
;;; the swank:* functions in the next section which do the useful work.
;;;
;;; To start a server do:
;;;   (swank-server-start)
;;;
;;; Then connect to it from Emacs using:
;;;   M-x slime-connect
;;; And accept the default options.
;;;

;; When SWANK commands are evaluated the output port is bound to a special
;; callback that sends the strings back to SLIME for printing. This function
;; produces a function that when executed always uses the default output
;; port. This means we can print debug messages to stdout rather than
;; sending them back to SLIME. Any function that can be called from a
;; swank:* function should be wrapped in this.
(define swank-with-normal-output-port-lambda
  (let ((normal-port (current-output-port)))
    (lambda (func)
      (lambda args
        (with-output-to-port normal-port
          (lambda ()
            (apply func args)))))))

;; Send list `msg' as a reply back to SLIME.
(define swank-write-packet
  (swank-with-normal-output-port-lambda
   (lambda (msg out)
     (define (pad-hex-string n pad)
       (let* ((base (format "~x" n))
              (length (string-length base)))
         (if (>= length pad)
             base
             (string-append (make-string (- pad length) #\0)
                            base))))

     (let* ((string (format "~a" msg))
            (packet (format "~a~a"
                            (pad-hex-string (string-length string) 6)
                            string)))
       (print (format "WRITE ~a" packet))
       (display packet out)
       (flush-output out)))))

;; Tail-recursive loop to read commands from SWANK socket and dispatch them.
(define (swank-event-loop in out)
  (let* ((length (read in))
         (request (read in)))
    (cond
     ((or (eof-object? length) (eof-object? request))
      (void))
     (else
      (print (format "READ ~a ~a" length request))
      (case (car request)
        ((:emacs-rex) (apply swank-emacs-rex out (cdr request))))
      (swank-event-loop in out)))))

;; Called when an exception is thrown while evaluating a swank:* function.
;; TODO: we need to communicate this back to SLIME - how?
(define swank-exception
  (swank-with-normal-output-port-lambda
   (lambda (exn)
     (let ((get-key (lambda (key)
                      ((condition-property-accessor 'exn key) exn))))
       (print (format "ERROR msg: ~a args: ~a loc ~a"
                      (get-key 'message)
                      (get-key 'arguments)
                      (get-key 'location)))))))

;; Create an output port that sends data back to SLIME to be printed on
;; the REPL.
(define (swank-output-port socket)
  (make-output-port
   (lambda (str)
     (swank-write-packet `(:write-string ,(format "~s" str))
                         socket))
   void
   void))

;; The only SWANK command we handle at the moment. Argument is an expression
;; to be evaluated, which should be a call to a swank:* function. Any output
;; produced by the expression will be returned to SLIME as a string. Any
;; error generated by the expression will be caught in the exception handler
;; above.
(define (swank-emacs-rex out sexp package thread id)
  (let ((result (call-with-current-continuation
                 (lambda (k)
                   (with-exception-handler
                    (lambda (exn)
                      (swank-exception exn)
                      (k '(:abort nil)))
                    (lambda ()
                      (with-output-to-port (swank-output-port out)
                        (lambda ()
                          (list ':ok (eval sexp))))))))))
    (swank-write-packet (list ':return result id) out)))

;; Start up a TCP server, wait for a connection, then jump into the main
;; event loop. If `file' is specified it is used as a filename to write
;; the server port number into. This is polled by SLIME to see if the
;; SWANK server has started. Use `swank-server-start' rather than calling
;; this directly.
(define (swank-make-server port file)
  (define (write-port-file port file)
    (call-with-output-file file
      (lambda (handle)
        (write port handle))))

  (tcp-read-timeout #f)

  (let ((listener (tcp-listen port)))
    (if file
        (write-port-file port file))
    (dynamic-wind
      (lambda () #f)
      
      (lambda ()
        (call-with-values
            (lambda () (tcp-accept listener))
          (lambda (in out)
            (swank-event-loop in out))))
      
      (lambda ()
        (tcp-close listener)))))

;; Wrapper for `swank-make-server' with optional `port' and `file' arguments.
(define swank-server-start
  (case-lambda
    (() (swank-make-server 4005 #f))
    ((port) (swank-make-server port #f))
    ((port file) (swank-make-server port file))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SWANK commands
;;;
;;; The functions in this section implement the SWANK API proper.
;;;

;; Called at startup to determine various information about the inferior
;; Lisp process.
;; TODO: add more (e.g. Chicken version) here
(define (swank:connection-info)
  `(:pid ,(current-process-id)
    :package (:name "CSI" :prompt "CSI")))

;; For us this call is fairly pointless, but it names the REPL.
(define (swank:create-repl _)
  (list "CSI" "CSI"))

;; Evaluate the expression `sexp' and return a list of results.
(define (swank:listener-eval sexp)

  (define (get-forms)
    (let ((form (read)))
      (cond
       ((eof-object? form) '())
       (else (cons form (get-forms))))))       

  (with-input-from-string sexp
    (lambda ()
      (call-with-values
          (lambda ()
            (let ((forms (get-forms)))
              (if (not (null? forms))
                  (eval `(begin ,@forms)))))
        (lambda results
          `(:values ,@(map (lambda (r)
                             (format "\"~a\"" r))
                           results)))))))

;; Definitions required for CL compatility
(define nil #f)
(define t #t)
